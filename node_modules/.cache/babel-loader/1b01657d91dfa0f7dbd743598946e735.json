{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.scrollama = factory();\n})(this, function () {\n  'use strict'; // DOM helper functions\n  // public\n\n  function selectAll(selector, parent) {\n    if (parent === void 0) parent = document;\n\n    if (typeof selector === 'string') {\n      return Array.from(parent.querySelectorAll(selector));\n    } else if (selector instanceof Element) {\n      return [selector];\n    } else if (selector instanceof NodeList) {\n      return Array.from(selector);\n    } else if (selector instanceof Array) {\n      return selector;\n    }\n\n    return [];\n  }\n\n  function getOffsetId(id) {\n    return \"scrollama__debug-offset--\" + id;\n  } // SETUP\n\n\n  function setupOffset(ref) {\n    var id = ref.id;\n    var offsetVal = ref.offsetVal;\n    var stepClass = ref.stepClass;\n    var el = document.createElement(\"div\");\n    el.id = getOffsetId(id);\n    el.className = \"scrollama__debug-offset\";\n    el.style.position = \"fixed\";\n    el.style.left = \"0\";\n    el.style.width = \"100%\";\n    el.style.height = \"0\";\n    el.style.borderTop = \"2px dashed black\";\n    el.style.zIndex = \"9999\";\n    var p = document.createElement(\"p\");\n    p.innerHTML = \"\\\".\" + stepClass + \"\\\" trigger: <span>\" + offsetVal + \"</span>\";\n    p.style.fontSize = \"12px\";\n    p.style.fontFamily = \"monospace\";\n    p.style.color = \"black\";\n    p.style.margin = \"0\";\n    p.style.padding = \"6px\";\n    el.appendChild(p);\n    document.body.appendChild(el);\n  }\n\n  function setup(ref) {\n    var id = ref.id;\n    var offsetVal = ref.offsetVal;\n    var stepEl = ref.stepEl;\n    var stepClass = stepEl[0].className;\n    setupOffset({\n      id: id,\n      offsetVal: offsetVal,\n      stepClass: stepClass\n    });\n  } // UPDATE\n\n\n  function update(ref) {\n    var id = ref.id;\n    var offsetMargin = ref.offsetMargin;\n    var offsetVal = ref.offsetVal;\n    var format = ref.format;\n    var post = format === \"pixels\" ? \"px\" : \"\";\n    var idVal = getOffsetId(id);\n    var el = document.getElementById(idVal);\n    el.style.top = offsetMargin + \"px\";\n    el.querySelector(\"span\").innerText = \"\" + offsetVal + post;\n  }\n\n  function notifyStep(ref) {\n    var id = ref.id;\n    var index = ref.index;\n    var state = ref.state;\n    var prefix = \"scrollama__debug-step--\" + id + \"-\" + index;\n    var elA = document.getElementById(prefix + \"_above\");\n    var elB = document.getElementById(prefix + \"_below\");\n    var display = state === \"enter\" ? \"block\" : \"none\";\n\n    if (elA) {\n      elA.style.display = display;\n    }\n\n    if (elB) {\n      elB.style.display = display;\n    }\n  }\n\n  function scrollama() {\n    var OBSERVER_NAMES = [\"stepAbove\", \"stepBelow\", \"stepProgress\", \"viewportAbove\", \"viewportBelow\"];\n    var cb = {};\n    var io = {};\n    var id = null;\n    var stepEl = [];\n    var stepOffsetHeight = [];\n    var stepOffsetTop = [];\n    var stepStates = [];\n    var offsetVal = 0;\n    var offsetMargin = 0;\n    var viewH = 0;\n    var pageH = 0;\n    var previousYOffset = 0;\n    var progressThreshold = 0;\n    var isReady = false;\n    var isEnabled = false;\n    var isDebug = false;\n    var progressMode = false;\n    var preserveOrder = false;\n    var triggerOnce = false;\n    var direction = \"down\";\n    var format = \"percent\";\n    var exclude = [];\n    /* HELPERS */\n\n    function err(msg) {\n      console.error(\"scrollama error: \" + msg);\n    }\n\n    function reset() {\n      cb = {\n        stepEnter: function () {},\n        stepExit: function () {},\n        stepProgress: function () {}\n      };\n      io = {};\n    }\n\n    function generateInstanceID() {\n      var a = \"abcdefghijklmnopqrstuv\";\n      var l = a.length;\n      var t = Date.now();\n      var r = [0, 0, 0].map(function (d) {\n        return a[Math.floor(Math.random() * l)];\n      }).join(\"\");\n      return \"\" + r + t;\n    }\n\n    function getOffsetTop(el) {\n      var ref = el.getBoundingClientRect();\n      var top = ref.top;\n      var scrollTop = window.pageYOffset;\n      var clientTop = document.body.clientTop || 0;\n      return top + scrollTop - clientTop;\n    }\n\n    function getPageHeight() {\n      var body = document.body;\n      var html = document.documentElement;\n      return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n    }\n\n    function getIndex(element) {\n      return +element.getAttribute(\"data-scrollama-index\");\n    }\n\n    function updateDirection() {\n      if (window.pageYOffset > previousYOffset) {\n        direction = \"down\";\n      } else if (window.pageYOffset < previousYOffset) {\n        direction = \"up\";\n      }\n\n      previousYOffset = window.pageYOffset;\n    }\n\n    function disconnectObserver(name) {\n      if (io[name]) {\n        io[name].forEach(function (d) {\n          return d.disconnect();\n        });\n      }\n    }\n\n    function handleResize() {\n      viewH = window.innerHeight;\n      pageH = getPageHeight();\n      var mult = format === \"pixels\" ? 1 : viewH;\n      offsetMargin = offsetVal * mult;\n\n      if (isReady) {\n        stepOffsetHeight = stepEl.map(function (el) {\n          return el.getBoundingClientRect().height;\n        });\n        stepOffsetTop = stepEl.map(getOffsetTop);\n\n        if (isEnabled) {\n          updateIO();\n        }\n      }\n\n      if (isDebug) {\n        update({\n          id: id,\n          offsetMargin: offsetMargin,\n          offsetVal: offsetVal,\n          format: format\n        });\n      }\n    }\n\n    function handleEnable(enable) {\n      if (enable && !isEnabled) {\n        // enable a disabled scroller\n        if (isReady) {\n          // enable a ready scroller\n          updateIO();\n        } else {\n          // can't enable an unready scroller\n          err(\"scrollama error: enable() called before scroller was ready\");\n          isEnabled = false;\n          return; // all is not well, don't set the requested state\n        }\n      }\n\n      if (!enable && isEnabled) {\n        // disable an enabled scroller\n        OBSERVER_NAMES.forEach(disconnectObserver);\n      }\n\n      isEnabled = enable; // all is well, set requested state\n    }\n\n    function createThreshold(height) {\n      var count = Math.ceil(height / progressThreshold);\n      var t = [];\n      var ratio = 1 / count;\n\n      for (var i = 0; i < count; i += 1) {\n        t.push(i * ratio);\n      }\n\n      return t;\n    }\n    /* NOTIFY CALLBACKS */\n\n\n    function notifyStepProgress(element, progress) {\n      var index = getIndex(element);\n\n      if (progress !== undefined) {\n        stepStates[index].progress = progress;\n      }\n\n      var resp = {\n        element: element,\n        index: index,\n        progress: stepStates[index].progress\n      };\n\n      if (stepStates[index].state === \"enter\") {\n        cb.stepProgress(resp);\n      }\n    }\n\n    function notifyOthers(index, location) {\n      if (location === \"above\") {\n        // check if steps above/below were skipped and should be notified first\n        for (var i = 0; i < index; i += 1) {\n          var ss = stepStates[i];\n\n          if (ss.state !== \"enter\" && ss.direction !== \"down\") {\n            notifyStepEnter(stepEl[i], \"down\", false);\n            notifyStepExit(stepEl[i], \"down\");\n          } else if (ss.state === \"enter\") {\n            notifyStepExit(stepEl[i], \"down\");\n          } // else if (ss.direction === 'up') {\n          //   notifyStepEnter(stepEl[i], 'down', false);\n          //   notifyStepExit(stepEl[i], 'down');\n          // }\n\n        }\n      } else if (location === \"below\") {\n        for (var i$1 = stepStates.length - 1; i$1 > index; i$1 -= 1) {\n          var ss$1 = stepStates[i$1];\n\n          if (ss$1.state === \"enter\") {\n            notifyStepExit(stepEl[i$1], \"up\");\n          }\n\n          if (ss$1.direction === \"down\") {\n            notifyStepEnter(stepEl[i$1], \"up\", false);\n            notifyStepExit(stepEl[i$1], \"up\");\n          }\n        }\n      }\n    }\n\n    function notifyStepEnter(element, dir, check) {\n      if (check === void 0) check = true;\n      var index = getIndex(element);\n      var resp = {\n        element: element,\n        index: index,\n        direction: dir\n      }; // store most recent trigger\n\n      stepStates[index].direction = dir;\n      stepStates[index].state = \"enter\";\n\n      if (preserveOrder && check && dir === \"down\") {\n        notifyOthers(index, \"above\");\n      }\n\n      if (preserveOrder && check && dir === \"up\") {\n        notifyOthers(index, \"below\");\n      }\n\n      if (cb.stepEnter && !exclude[index]) {\n        cb.stepEnter(resp, stepStates);\n\n        if (isDebug) {\n          notifyStep({\n            id: id,\n            index: index,\n            state: \"enter\"\n          });\n        }\n\n        if (triggerOnce) {\n          exclude[index] = true;\n        }\n      }\n\n      if (progressMode) {\n        notifyStepProgress(element);\n      }\n    }\n\n    function notifyStepExit(element, dir) {\n      var index = getIndex(element);\n      var resp = {\n        element: element,\n        index: index,\n        direction: dir\n      };\n\n      if (progressMode) {\n        if (dir === \"down\" && stepStates[index].progress < 1) {\n          notifyStepProgress(element, 1);\n        } else if (dir === \"up\" && stepStates[index].progress > 0) {\n          notifyStepProgress(element, 0);\n        }\n      } // store most recent trigger\n\n\n      stepStates[index].direction = dir;\n      stepStates[index].state = \"exit\";\n      cb.stepExit(resp, stepStates);\n\n      if (isDebug) {\n        notifyStep({\n          id: id,\n          index: index,\n          state: \"exit\"\n        });\n      }\n    }\n    /* OBSERVER - INTERSECT HANDLING */\n    // this is good for entering while scrolling down + leaving while scrolling up\n\n\n    function intersectStepAbove(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target; // bottom = bottom edge of element from top of viewport\n      // bottomAdjusted = bottom edge of element from trigger\n\n      var top = boundingClientRect.top;\n      var bottom = boundingClientRect.bottom;\n      var topAdjusted = top - offsetMargin;\n      var bottomAdjusted = bottom - offsetMargin;\n      var index = getIndex(target);\n      var ss = stepStates[index]; // entering above is only when topAdjusted is negative\n      // and bottomAdjusted is positive\n\n      if (isIntersecting && topAdjusted <= 0 && bottomAdjusted >= 0 && direction === \"down\" && ss.state !== \"enter\") {\n        notifyStepEnter(target, direction);\n      } // exiting from above is when topAdjusted is positive and not intersecting\n\n\n      if (!isIntersecting && topAdjusted > 0 && direction === \"up\" && ss.state === \"enter\") {\n        notifyStepExit(target, direction);\n      }\n    } // this is good for entering while scrolling up + leaving while scrolling down\n\n\n    function intersectStepBelow(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target; // bottom = bottom edge of element from top of viewport\n      // bottomAdjusted = bottom edge of element from trigger\n\n      var top = boundingClientRect.top;\n      var bottom = boundingClientRect.bottom;\n      var topAdjusted = top - offsetMargin;\n      var bottomAdjusted = bottom - offsetMargin;\n      var index = getIndex(target);\n      var ss = stepStates[index]; // entering below is only when bottomAdjusted is positive\n      // and topAdjusted is negative\n\n      if (isIntersecting && topAdjusted <= 0 && bottomAdjusted >= 0 && direction === \"up\" && ss.state !== \"enter\") {\n        notifyStepEnter(target, direction);\n      } // exiting from above is when bottomAdjusted is negative and not intersecting\n\n\n      if (!isIntersecting && bottomAdjusted < 0 && direction === \"down\" && ss.state === \"enter\") {\n        notifyStepExit(target, direction);\n      }\n    }\n    /*\n    if there is a scroll event where a step never intersects (therefore\n    skipping an enter/exit trigger), use this fallback to detect if it is\n    in view\n    */\n\n\n    function intersectViewportAbove(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var target = entry.target;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n\n      if (isIntersecting && direction === \"down\" && ss.direction !== \"down\" && ss.state !== \"enter\") {\n        notifyStepEnter(target, \"down\");\n        notifyStepExit(target, \"down\");\n      }\n    }\n\n    function intersectViewportBelow(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var target = entry.target;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n\n      if (isIntersecting && direction === \"up\" && ss.direction === \"down\" && ss.state !== \"enter\") {\n        notifyStepEnter(target, \"up\");\n        notifyStepExit(target, \"up\");\n      }\n    }\n\n    function intersectStepProgress(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var intersectionRatio = entry.intersectionRatio;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target;\n      var bottom = boundingClientRect.bottom;\n      var bottomAdjusted = bottom - offsetMargin;\n\n      if (isIntersecting && bottomAdjusted >= 0) {\n        notifyStepProgress(target, +intersectionRatio);\n      }\n    }\n    /*  OBSERVER - CREATION */\n    // jump into viewport\n\n\n    function updateViewportAboveIO() {\n      io.viewportAbove = stepEl.map(function (el, i) {\n        var marginTop = pageH - stepOffsetTop[i];\n        var marginBottom = offsetMargin - viewH - stepOffsetHeight[i];\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectViewportAbove, options);\n        obs.observe(el);\n        return obs;\n      });\n    }\n\n    function updateViewportBelowIO() {\n      io.viewportBelow = stepEl.map(function (el, i) {\n        var marginTop = -offsetMargin - stepOffsetHeight[i];\n        var marginBottom = offsetMargin - viewH + stepOffsetHeight[i] + pageH;\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectViewportBelow, options);\n        obs.observe(el);\n        return obs;\n      });\n    } // look above for intersection\n\n\n    function updateStepAboveIO() {\n      io.stepAbove = stepEl.map(function (el, i) {\n        var marginTop = -offsetMargin + stepOffsetHeight[i];\n        var marginBottom = offsetMargin - viewH;\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectStepAbove, options);\n        obs.observe(el);\n        return obs;\n      });\n    } // look below for intersection\n\n\n    function updateStepBelowIO() {\n      io.stepBelow = stepEl.map(function (el, i) {\n        var marginTop = -offsetMargin;\n        var marginBottom = offsetMargin - viewH + stepOffsetHeight[i];\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectStepBelow, options);\n        obs.observe(el);\n        return obs;\n      });\n    } // progress progress tracker\n\n\n    function updateStepProgressIO() {\n      io.stepProgress = stepEl.map(function (el, i) {\n        var marginTop = stepOffsetHeight[i] - offsetMargin;\n        var marginBottom = -viewH + offsetMargin;\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var threshold = createThreshold(stepOffsetHeight[i]);\n        var options = {\n          rootMargin: rootMargin,\n          threshold: threshold\n        }; // console.log(options);\n\n        var obs = new IntersectionObserver(intersectStepProgress, options);\n        obs.observe(el);\n        return obs;\n      });\n    }\n\n    function updateIO() {\n      OBSERVER_NAMES.forEach(disconnectObserver);\n      updateViewportAboveIO();\n      updateViewportBelowIO();\n      updateStepAboveIO();\n      updateStepBelowIO();\n\n      if (progressMode) {\n        updateStepProgressIO();\n      }\n    }\n    /* SETUP FUNCTIONS */\n\n\n    function indexSteps() {\n      stepEl.forEach(function (el, i) {\n        return el.setAttribute(\"data-scrollama-index\", i);\n      });\n    }\n\n    function setupStates() {\n      stepStates = stepEl.map(function () {\n        return {\n          direction: null,\n          state: null,\n          progress: 0\n        };\n      });\n    }\n\n    function addDebug() {\n      if (isDebug) {\n        setup({\n          id: id,\n          stepEl: stepEl,\n          offsetVal: offsetVal\n        });\n      }\n    }\n\n    function isYScrollable(element) {\n      var style = window.getComputedStyle(element);\n      return (style.overflowY === \"scroll\" || style.overflowY === \"auto\") && element.scrollHeight > element.clientHeight;\n    } // recursively search the DOM for a parent container with overflowY: scroll and fixed height\n    // ends at document\n\n\n    function anyScrollableParent(element) {\n      if (element && element.nodeType === 1) {\n        // check dom elements only, stop at document\n        // if a scrollable element is found return the element\n        // if not continue to next parent\n        return isYScrollable(element) ? element : anyScrollableParent(element.parentNode);\n      }\n\n      return false; // didn't find a scrollable parent\n    }\n\n    var S = {};\n\n    S.setup = function (ref) {\n      var step = ref.step;\n      var offset = ref.offset;\n      if (offset === void 0) offset = 0.5;\n      var progress = ref.progress;\n      if (progress === void 0) progress = false;\n      var threshold = ref.threshold;\n      if (threshold === void 0) threshold = 4;\n      var debug = ref.debug;\n      if (debug === void 0) debug = false;\n      var order = ref.order;\n      if (order === void 0) order = true;\n      var once = ref.once;\n      if (once === void 0) once = false;\n      reset(); // create id unique to this scrollama instance\n\n      id = generateInstanceID();\n      stepEl = selectAll(step);\n\n      if (!stepEl.length) {\n        err(\"no step elements\");\n        return S;\n      } // ensure that no step has a scrollable parent element in the dom tree\n      // check current step for scrollable parent\n      // assume no scrollable parents to start\n\n\n      var scrollableParent = stepEl.reduce(function (foundScrollable, s) {\n        return foundScrollable || anyScrollableParent(s.parentNode);\n      }, false);\n\n      if (scrollableParent) {\n        console.error(\"scrollama error: step elements cannot be children of a scrollable element. Remove any css on the parent element with overflow: scroll; or overflow: auto; on elements with fixed height.\", scrollableParent);\n      } // options\n\n\n      isDebug = debug;\n      progressMode = progress;\n      preserveOrder = order;\n      triggerOnce = once;\n      S.offsetTrigger(offset);\n      progressThreshold = Math.max(1, +threshold);\n      isReady = true; // customize\n\n      addDebug();\n      indexSteps();\n      setupStates();\n      handleResize();\n      S.enable();\n      return S;\n    };\n\n    S.resize = function () {\n      handleResize();\n      return S;\n    };\n\n    S.enable = function () {\n      handleEnable(true);\n      return S;\n    };\n\n    S.disable = function () {\n      handleEnable(false);\n      return S;\n    };\n\n    S.destroy = function () {\n      handleEnable(false);\n      reset();\n    };\n\n    S.offsetTrigger = function (x) {\n      if (x === null) {\n        return offsetVal;\n      }\n\n      if (typeof x === \"number\") {\n        format = \"percent\";\n\n        if (x > 1) {\n          err(\"offset value is greater than 1. Fallback to 1.\");\n        }\n\n        if (x < 0) {\n          err(\"offset value is lower than 0. Fallback to 0.\");\n        }\n\n        offsetVal = Math.min(Math.max(0, x), 1);\n      } else if (typeof x === \"string\" && x.indexOf(\"px\") > 0) {\n        var v = +x.replace(\"px\", \"\");\n\n        if (!isNaN(v)) {\n          format = \"pixels\";\n          offsetVal = v;\n        } else {\n          err(\"offset value must be in 'px' format. Fallback to 0.5.\");\n          offsetVal = 0.5;\n        }\n      } else {\n        err(\"offset value does not include 'px'. Fallback to 0.5.\");\n        offsetVal = 0.5;\n      }\n\n      return S;\n    };\n\n    S.onStepEnter = function (f) {\n      if (typeof f === \"function\") {\n        cb.stepEnter = f;\n      } else {\n        err(\"onStepEnter requires a function\");\n      }\n\n      return S;\n    };\n\n    S.onStepExit = function (f) {\n      if (typeof f === \"function\") {\n        cb.stepExit = f;\n      } else {\n        err(\"onStepExit requires a function\");\n      }\n\n      return S;\n    };\n\n    S.onStepProgress = function (f) {\n      if (typeof f === \"function\") {\n        cb.stepProgress = f;\n      } else {\n        err(\"onStepProgress requires a function\");\n      }\n\n      return S;\n    };\n\n    return S;\n  }\n\n  return scrollama;\n});","map":{"version":3,"sources":["/Users/charles/Documents/GitHub/1/revolution-2019/node_modules/scrollama/build/scrollama.js"],"names":["global","factory","exports","module","define","amd","scrollama","selectAll","selector","parent","document","Array","from","querySelectorAll","Element","NodeList","getOffsetId","id","setupOffset","ref","offsetVal","stepClass","el","createElement","className","style","position","left","width","height","borderTop","zIndex","p","innerHTML","fontSize","fontFamily","color","margin","padding","appendChild","body","setup","stepEl","update","offsetMargin","format","post","idVal","getElementById","top","querySelector","innerText","notifyStep","index","state","prefix","elA","elB","display","OBSERVER_NAMES","cb","io","stepOffsetHeight","stepOffsetTop","stepStates","viewH","pageH","previousYOffset","progressThreshold","isReady","isEnabled","isDebug","progressMode","preserveOrder","triggerOnce","direction","exclude","err","msg","console","error","reset","stepEnter","stepExit","stepProgress","generateInstanceID","a","l","length","t","Date","now","r","map","d","Math","floor","random","join","getOffsetTop","getBoundingClientRect","scrollTop","window","pageYOffset","clientTop","getPageHeight","html","documentElement","max","scrollHeight","offsetHeight","clientHeight","getIndex","element","getAttribute","updateDirection","disconnectObserver","name","forEach","disconnect","handleResize","innerHeight","mult","updateIO","handleEnable","enable","createThreshold","count","ceil","ratio","i","push","notifyStepProgress","progress","undefined","resp","notifyOthers","location","ss","notifyStepEnter","notifyStepExit","i$1","ss$1","dir","check","intersectStepAbove","entry","isIntersecting","boundingClientRect","target","bottom","topAdjusted","bottomAdjusted","intersectStepBelow","intersectViewportAbove","intersectViewportBelow","intersectStepProgress","intersectionRatio","updateViewportAboveIO","viewportAbove","marginTop","marginBottom","rootMargin","options","obs","IntersectionObserver","observe","updateViewportBelowIO","viewportBelow","updateStepAboveIO","stepAbove","updateStepBelowIO","stepBelow","updateStepProgressIO","threshold","indexSteps","setAttribute","setupStates","addDebug","isYScrollable","getComputedStyle","overflowY","anyScrollableParent","nodeType","parentNode","S","step","offset","debug","order","once","scrollableParent","reduce","foundScrollable","s","offsetTrigger","resize","disable","destroy","x","min","indexOf","v","replace","isNaN","onStepEnter","f","onStepExit","onStepProgress"],"mappings":"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","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.scrollama = factory());\n}(this, (function () { 'use strict';\n\n// DOM helper functions\n\n// public\nfunction selectAll(selector, parent) {\n  if ( parent === void 0 ) parent = document;\n\n  if (typeof selector === 'string') {\n    return Array.from(parent.querySelectorAll(selector));\n  } else if (selector instanceof Element) {\n    return [selector];\n  } else if (selector instanceof NodeList) {\n    return Array.from(selector);\n  } else if (selector instanceof Array) {\n    return selector;\n  }\n  return [];\n}\n\nfunction getOffsetId(id) {\n  return (\"scrollama__debug-offset--\" + id);\n}\n\n// SETUP\nfunction setupOffset(ref) {\n  var id = ref.id;\n  var offsetVal = ref.offsetVal;\n  var stepClass = ref.stepClass;\n\n  var el = document.createElement(\"div\");\n  el.id = getOffsetId(id);\n  el.className = \"scrollama__debug-offset\";\n  el.style.position = \"fixed\";\n  el.style.left = \"0\";\n  el.style.width = \"100%\";\n  el.style.height = \"0\";\n  el.style.borderTop = \"2px dashed black\";\n  el.style.zIndex = \"9999\";\n\n  var p = document.createElement(\"p\");\n  p.innerHTML = \"\\\".\" + stepClass + \"\\\" trigger: <span>\" + offsetVal + \"</span>\";\n  p.style.fontSize = \"12px\";\n  p.style.fontFamily = \"monospace\";\n  p.style.color = \"black\";\n  p.style.margin = \"0\";\n  p.style.padding = \"6px\";\n  el.appendChild(p);\n  document.body.appendChild(el);\n}\n\nfunction setup(ref) {\n  var id = ref.id;\n  var offsetVal = ref.offsetVal;\n  var stepEl = ref.stepEl;\n\n  var stepClass = stepEl[0].className;\n  setupOffset({ id: id, offsetVal: offsetVal, stepClass: stepClass });\n}\n\n// UPDATE\nfunction update(ref) {\n  var id = ref.id;\n  var offsetMargin = ref.offsetMargin;\n  var offsetVal = ref.offsetVal;\n  var format = ref.format;\n\n  var post = format === \"pixels\" ? \"px\" : \"\";\n  var idVal = getOffsetId(id);\n  var el = document.getElementById(idVal);\n  el.style.top = offsetMargin + \"px\";\n  el.querySelector(\"span\").innerText = \"\" + offsetVal + post;\n}\n\nfunction notifyStep(ref) {\n  var id = ref.id;\n  var index = ref.index;\n  var state = ref.state;\n\n  var prefix = \"scrollama__debug-step--\" + id + \"-\" + index;\n  var elA = document.getElementById((prefix + \"_above\"));\n  var elB = document.getElementById((prefix + \"_below\"));\n  var display = state === \"enter\" ? \"block\" : \"none\";\n\n  if (elA) { elA.style.display = display; }\n  if (elB) { elB.style.display = display; }\n}\n\nfunction scrollama() {\n  var OBSERVER_NAMES = [\n    \"stepAbove\",\n    \"stepBelow\",\n    \"stepProgress\",\n    \"viewportAbove\",\n    \"viewportBelow\"\n  ];\n\n  var cb = {};\n  var io = {};\n\n  var id = null;\n  var stepEl = [];\n  var stepOffsetHeight = [];\n  var stepOffsetTop = [];\n  var stepStates = [];\n\n  var offsetVal = 0;\n  var offsetMargin = 0;\n  var viewH = 0;\n  var pageH = 0;\n  var previousYOffset = 0;\n  var progressThreshold = 0;\n\n  var isReady = false;\n  var isEnabled = false;\n  var isDebug = false;\n\n  var progressMode = false;\n  var preserveOrder = false;\n  var triggerOnce = false;\n\n  var direction = \"down\";\n  var format = \"percent\";\n\n  var exclude = [];\n\n  /* HELPERS */\n  function err(msg) {\n    console.error((\"scrollama error: \" + msg));\n  }\n\n  function reset() {\n    cb = {\n      stepEnter: function () {},\n      stepExit: function () {},\n      stepProgress: function () {}\n    };\n    io = {};\n  }\n\n  function generateInstanceID() {\n    var a = \"abcdefghijklmnopqrstuv\";\n    var l = a.length;\n    var t = Date.now();\n    var r = [0, 0, 0].map(function (d) { return a[Math.floor(Math.random() * l)]; }).join(\"\");\n    return (\"\" + r + t);\n  }\n\n  function getOffsetTop(el) {\n    var ref = el.getBoundingClientRect();\n    var top = ref.top;\n    var scrollTop = window.pageYOffset;\n    var clientTop = document.body.clientTop || 0;\n    return top + scrollTop - clientTop;\n  }\n\n  function getPageHeight() {\n    var body = document.body;\n    var html = document.documentElement;\n\n    return Math.max(\n      body.scrollHeight,\n      body.offsetHeight,\n      html.clientHeight,\n      html.scrollHeight,\n      html.offsetHeight\n    );\n  }\n\n  function getIndex(element) {\n    return +element.getAttribute(\"data-scrollama-index\");\n  }\n\n  function updateDirection() {\n    if (window.pageYOffset > previousYOffset) { direction = \"down\"; }\n    else if (window.pageYOffset < previousYOffset) { direction = \"up\"; }\n    previousYOffset = window.pageYOffset;\n  }\n\n  function disconnectObserver(name) {\n    if (io[name]) { io[name].forEach(function (d) { return d.disconnect(); }); }\n  }\n\n  function handleResize() {\n    viewH = window.innerHeight;\n    pageH = getPageHeight();\n\n    var mult = format === \"pixels\" ? 1 : viewH;\n    offsetMargin = offsetVal * mult;\n\n    if (isReady) {\n      stepOffsetHeight = stepEl.map(function (el) { return el.getBoundingClientRect().height; });\n      stepOffsetTop = stepEl.map(getOffsetTop);\n      if (isEnabled) { updateIO(); }\n    }\n\n    if (isDebug) { update({ id: id, offsetMargin: offsetMargin, offsetVal: offsetVal, format: format }); }\n  }\n\n  function handleEnable(enable) {\n    if (enable && !isEnabled) {\n      // enable a disabled scroller\n      if (isReady) {\n        // enable a ready scroller\n        updateIO();\n      } else {\n        // can't enable an unready scroller\n        err(\"scrollama error: enable() called before scroller was ready\");\n        isEnabled = false;\n        return; // all is not well, don't set the requested state\n      }\n    }\n    if (!enable && isEnabled) {\n      // disable an enabled scroller\n      OBSERVER_NAMES.forEach(disconnectObserver);\n    }\n    isEnabled = enable; // all is well, set requested state\n  }\n\n  function createThreshold(height) {\n    var count = Math.ceil(height / progressThreshold);\n    var t = [];\n    var ratio = 1 / count;\n    for (var i = 0; i < count; i += 1) {\n      t.push(i * ratio);\n    }\n    return t;\n  }\n\n  /* NOTIFY CALLBACKS */\n  function notifyStepProgress(element, progress) {\n    var index = getIndex(element);\n    if (progress !== undefined) { stepStates[index].progress = progress; }\n    var resp = { element: element, index: index, progress: stepStates[index].progress };\n\n    if (stepStates[index].state === \"enter\") { cb.stepProgress(resp); }\n  }\n\n  function notifyOthers(index, location) {\n    if (location === \"above\") {\n      // check if steps above/below were skipped and should be notified first\n      for (var i = 0; i < index; i += 1) {\n        var ss = stepStates[i];\n        if (ss.state !== \"enter\" && ss.direction !== \"down\") {\n          notifyStepEnter(stepEl[i], \"down\", false);\n          notifyStepExit(stepEl[i], \"down\");\n        } else if (ss.state === \"enter\") { notifyStepExit(stepEl[i], \"down\"); }\n        // else if (ss.direction === 'up') {\n        //   notifyStepEnter(stepEl[i], 'down', false);\n        //   notifyStepExit(stepEl[i], 'down');\n        // }\n      }\n    } else if (location === \"below\") {\n      for (var i$1 = stepStates.length - 1; i$1 > index; i$1 -= 1) {\n        var ss$1 = stepStates[i$1];\n        if (ss$1.state === \"enter\") {\n          notifyStepExit(stepEl[i$1], \"up\");\n        }\n        if (ss$1.direction === \"down\") {\n          notifyStepEnter(stepEl[i$1], \"up\", false);\n          notifyStepExit(stepEl[i$1], \"up\");\n        }\n      }\n    }\n  }\n\n  function notifyStepEnter(element, dir, check) {\n    if ( check === void 0 ) check = true;\n\n    var index = getIndex(element);\n    var resp = { element: element, index: index, direction: dir };\n\n    // store most recent trigger\n    stepStates[index].direction = dir;\n    stepStates[index].state = \"enter\";\n    if (preserveOrder && check && dir === \"down\") { notifyOthers(index, \"above\"); }\n\n    if (preserveOrder && check && dir === \"up\") { notifyOthers(index, \"below\"); }\n\n    if (cb.stepEnter && !exclude[index]) {\n      cb.stepEnter(resp, stepStates);\n      if (isDebug) { notifyStep({ id: id, index: index, state: \"enter\" }); }\n      if (triggerOnce) { exclude[index] = true; }\n    }\n\n    if (progressMode) { notifyStepProgress(element); }\n  }\n\n  function notifyStepExit(element, dir) {\n    var index = getIndex(element);\n    var resp = { element: element, index: index, direction: dir };\n\n    if (progressMode) {\n      if (dir === \"down\" && stepStates[index].progress < 1)\n        { notifyStepProgress(element, 1); }\n      else if (dir === \"up\" && stepStates[index].progress > 0)\n        { notifyStepProgress(element, 0); }\n    }\n\n    // store most recent trigger\n    stepStates[index].direction = dir;\n    stepStates[index].state = \"exit\";\n\n    cb.stepExit(resp, stepStates);\n    if (isDebug) { notifyStep({ id: id, index: index, state: \"exit\" }); }\n  }\n\n  /* OBSERVER - INTERSECT HANDLING */\n  // this is good for entering while scrolling down + leaving while scrolling up\n  function intersectStepAbove(ref) {\n    var entry = ref[0];\n\n    updateDirection();\n    var isIntersecting = entry.isIntersecting;\n    var boundingClientRect = entry.boundingClientRect;\n    var target = entry.target;\n\n    // bottom = bottom edge of element from top of viewport\n    // bottomAdjusted = bottom edge of element from trigger\n    var top = boundingClientRect.top;\n    var bottom = boundingClientRect.bottom;\n    var topAdjusted = top - offsetMargin;\n    var bottomAdjusted = bottom - offsetMargin;\n    var index = getIndex(target);\n    var ss = stepStates[index];\n\n    // entering above is only when topAdjusted is negative\n    // and bottomAdjusted is positive\n    if (\n      isIntersecting &&\n      topAdjusted <= 0 &&\n      bottomAdjusted >= 0 &&\n      direction === \"down\" &&\n      ss.state !== \"enter\"\n    )\n      { notifyStepEnter(target, direction); }\n\n    // exiting from above is when topAdjusted is positive and not intersecting\n    if (\n      !isIntersecting &&\n      topAdjusted > 0 &&\n      direction === \"up\" &&\n      ss.state === \"enter\"\n    )\n      { notifyStepExit(target, direction); }\n  }\n\n  // this is good for entering while scrolling up + leaving while scrolling down\n  function intersectStepBelow(ref) {\n    var entry = ref[0];\n\n    updateDirection();\n    var isIntersecting = entry.isIntersecting;\n    var boundingClientRect = entry.boundingClientRect;\n    var target = entry.target;\n\n    // bottom = bottom edge of element from top of viewport\n    // bottomAdjusted = bottom edge of element from trigger\n    var top = boundingClientRect.top;\n    var bottom = boundingClientRect.bottom;\n    var topAdjusted = top - offsetMargin;\n    var bottomAdjusted = bottom - offsetMargin;\n    var index = getIndex(target);\n    var ss = stepStates[index];\n\n    // entering below is only when bottomAdjusted is positive\n    // and topAdjusted is negative\n    if (\n      isIntersecting &&\n      topAdjusted <= 0 &&\n      bottomAdjusted >= 0 &&\n      direction === \"up\" &&\n      ss.state !== \"enter\"\n    )\n      { notifyStepEnter(target, direction); }\n\n    // exiting from above is when bottomAdjusted is negative and not intersecting\n    if (\n      !isIntersecting &&\n      bottomAdjusted < 0 &&\n      direction === \"down\" &&\n      ss.state === \"enter\"\n    )\n      { notifyStepExit(target, direction); }\n  }\n\n  /*\n\tif there is a scroll event where a step never intersects (therefore\n\tskipping an enter/exit trigger), use this fallback to detect if it is\n\tin view\n\t*/\n  function intersectViewportAbove(ref) {\n    var entry = ref[0];\n\n    updateDirection();\n    var isIntersecting = entry.isIntersecting;\n    var target = entry.target;\n    var index = getIndex(target);\n    var ss = stepStates[index];\n\n    if (\n      isIntersecting &&\n      direction === \"down\" &&\n      ss.direction !== \"down\" &&\n      ss.state !== \"enter\"\n    ) {\n      notifyStepEnter(target, \"down\");\n      notifyStepExit(target, \"down\");\n    }\n  }\n\n  function intersectViewportBelow(ref) {\n    var entry = ref[0];\n\n    updateDirection();\n    var isIntersecting = entry.isIntersecting;\n    var target = entry.target;\n    var index = getIndex(target);\n    var ss = stepStates[index];\n    if (\n      isIntersecting &&\n      direction === \"up\" &&\n      ss.direction === \"down\" &&\n      ss.state !== \"enter\"\n    ) {\n      notifyStepEnter(target, \"up\");\n      notifyStepExit(target, \"up\");\n    }\n  }\n\n  function intersectStepProgress(ref) {\n    var entry = ref[0];\n\n    updateDirection();\n    var isIntersecting = entry.isIntersecting;\n    var intersectionRatio = entry.intersectionRatio;\n    var boundingClientRect = entry.boundingClientRect;\n    var target = entry.target;\n    var bottom = boundingClientRect.bottom;\n    var bottomAdjusted = bottom - offsetMargin;\n    if (isIntersecting && bottomAdjusted >= 0) {\n      notifyStepProgress(target, +intersectionRatio);\n    }\n  }\n\n  /*  OBSERVER - CREATION */\n  // jump into viewport\n  function updateViewportAboveIO() {\n    io.viewportAbove = stepEl.map(function (el, i) {\n      var marginTop = pageH - stepOffsetTop[i];\n      var marginBottom = offsetMargin - viewH - stepOffsetHeight[i];\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n      var options = { rootMargin: rootMargin };\n      // console.log(options);\n      var obs = new IntersectionObserver(intersectViewportAbove, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  function updateViewportBelowIO() {\n    io.viewportBelow = stepEl.map(function (el, i) {\n      var marginTop = -offsetMargin - stepOffsetHeight[i];\n      var marginBottom = offsetMargin - viewH + stepOffsetHeight[i] + pageH;\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n      var options = { rootMargin: rootMargin };\n      // console.log(options);\n      var obs = new IntersectionObserver(intersectViewportBelow, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  // look above for intersection\n  function updateStepAboveIO() {\n    io.stepAbove = stepEl.map(function (el, i) {\n      var marginTop = -offsetMargin + stepOffsetHeight[i];\n      var marginBottom = offsetMargin - viewH;\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n      var options = { rootMargin: rootMargin };\n      // console.log(options);\n      var obs = new IntersectionObserver(intersectStepAbove, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  // look below for intersection\n  function updateStepBelowIO() {\n    io.stepBelow = stepEl.map(function (el, i) {\n      var marginTop = -offsetMargin;\n      var marginBottom = offsetMargin - viewH + stepOffsetHeight[i];\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n      var options = { rootMargin: rootMargin };\n      // console.log(options);\n      var obs = new IntersectionObserver(intersectStepBelow, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  // progress progress tracker\n  function updateStepProgressIO() {\n    io.stepProgress = stepEl.map(function (el, i) {\n      var marginTop = stepOffsetHeight[i] - offsetMargin;\n      var marginBottom = -viewH + offsetMargin;\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n      var threshold = createThreshold(stepOffsetHeight[i]);\n      var options = { rootMargin: rootMargin, threshold: threshold };\n      // console.log(options);\n      var obs = new IntersectionObserver(intersectStepProgress, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  function updateIO() {\n    OBSERVER_NAMES.forEach(disconnectObserver);\n\n    updateViewportAboveIO();\n    updateViewportBelowIO();\n    updateStepAboveIO();\n    updateStepBelowIO();\n\n    if (progressMode) { updateStepProgressIO(); }\n  }\n\n  /* SETUP FUNCTIONS */\n\n  function indexSteps() {\n    stepEl.forEach(function (el, i) { return el.setAttribute(\"data-scrollama-index\", i); });\n  }\n\n  function setupStates() {\n    stepStates = stepEl.map(function () { return ({\n      direction: null,\n      state: null,\n      progress: 0\n    }); });\n  }\n\n  function addDebug() {\n    if (isDebug) { setup({ id: id, stepEl: stepEl, offsetVal: offsetVal }); }\n  }\n\n  function isYScrollable(element) {\n    var style = window.getComputedStyle(element);\n    return (\n      (style.overflowY === \"scroll\" || style.overflowY === \"auto\") &&\n      element.scrollHeight > element.clientHeight\n    );\n  }\n\n  // recursively search the DOM for a parent container with overflowY: scroll and fixed height\n  // ends at document\n  function anyScrollableParent(element) {\n    if (element && element.nodeType === 1) {\n      // check dom elements only, stop at document\n      // if a scrollable element is found return the element\n      // if not continue to next parent\n      return isYScrollable(element)\n        ? element\n        : anyScrollableParent(element.parentNode);\n    }\n    return false; // didn't find a scrollable parent\n  }\n\n  var S = {};\n\n  S.setup = function (ref) {\n    var step = ref.step;\n    var offset = ref.offset; if ( offset === void 0 ) offset = 0.5;\n    var progress = ref.progress; if ( progress === void 0 ) progress = false;\n    var threshold = ref.threshold; if ( threshold === void 0 ) threshold = 4;\n    var debug = ref.debug; if ( debug === void 0 ) debug = false;\n    var order = ref.order; if ( order === void 0 ) order = true;\n    var once = ref.once; if ( once === void 0 ) once = false;\n\n    reset();\n    // create id unique to this scrollama instance\n    id = generateInstanceID();\n\n    stepEl = selectAll(step);\n\n    if (!stepEl.length) {\n      err(\"no step elements\");\n      return S;\n    }\n\n    // ensure that no step has a scrollable parent element in the dom tree\n    // check current step for scrollable parent\n    // assume no scrollable parents to start\n    var scrollableParent = stepEl.reduce(\n      function (foundScrollable, s) { return foundScrollable || anyScrollableParent(s.parentNode); },\n      false\n    );\n    if (scrollableParent) {\n      console.error(\n        \"scrollama error: step elements cannot be children of a scrollable element. Remove any css on the parent element with overflow: scroll; or overflow: auto; on elements with fixed height.\",\n        scrollableParent\n      );\n    }\n\n    // options\n    isDebug = debug;\n    progressMode = progress;\n    preserveOrder = order;\n    triggerOnce = once;\n\n    S.offsetTrigger(offset);\n    progressThreshold = Math.max(1, +threshold);\n\n    isReady = true;\n\n    // customize\n    addDebug();\n    indexSteps();\n    setupStates();\n    handleResize();\n    S.enable();\n    return S;\n  };\n\n  S.resize = function () {\n    handleResize();\n    return S;\n  };\n\n  S.enable = function () {\n    handleEnable(true);\n    return S;\n  };\n\n  S.disable = function () {\n    handleEnable(false);\n    return S;\n  };\n\n  S.destroy = function () {\n    handleEnable(false);\n    reset();\n  };\n\n  S.offsetTrigger = function (x) {\n    if (x === null) { return offsetVal; }\n\n    if (typeof x === \"number\") {\n      format = \"percent\";\n      if (x > 1) { err(\"offset value is greater than 1. Fallback to 1.\"); }\n      if (x < 0) { err(\"offset value is lower than 0. Fallback to 0.\"); }\n      offsetVal = Math.min(Math.max(0, x), 1);\n    } else if (typeof x === \"string\" && x.indexOf(\"px\") > 0) {\n      var v = +x.replace(\"px\", \"\");\n      if (!isNaN(v)) {\n        format = \"pixels\";\n        offsetVal = v;\n      } else {\n        err(\"offset value must be in 'px' format. Fallback to 0.5.\");\n        offsetVal = 0.5;\n      }\n    } else {\n      err(\"offset value does not include 'px'. Fallback to 0.5.\");\n      offsetVal = 0.5;\n    }\n    return S;\n  };\n\n  S.onStepEnter = function (f) {\n    if (typeof f === \"function\") { cb.stepEnter = f; }\n    else { err(\"onStepEnter requires a function\"); }\n    return S;\n  };\n\n  S.onStepExit = function (f) {\n    if (typeof f === \"function\") { cb.stepExit = f; }\n    else { err(\"onStepExit requires a function\"); }\n    return S;\n  };\n\n  S.onStepProgress = function (f) {\n    if (typeof f === \"function\") { cb.stepProgress = f; }\n    else { err(\"onStepProgress requires a function\"); }\n    return S;\n  };\n\n  return S;\n}\n\nreturn scrollama;\n\n})));\n"]},"metadata":{},"sourceType":"script"}